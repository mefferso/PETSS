<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Waveland Coastal Flood Intel</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; padding: 14px; background: #fff; color: #111; }
    .wrap { max-width: 980px; margin: 0 auto; }
    .hdr { display:flex; align-items:baseline; justify-content:space-between; gap:12px; flex-wrap:wrap; }
    .title { font-size: 18px; font-weight: 700; }
    .sub { font-size: 12px; color:#555; }
    .grid { display:grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 12px; margin-top: 12px; }
    .card { border: 1px solid #e5e5e5; border-radius: 12px; padding: 12px; box-shadow: 0 1px 2px rgba(0,0,0,.04); }
    .card h3 { margin: 0 0 8px; font-size: 14px; }
    .kv { display:grid; grid-template-columns: 140px 1fr; gap: 6px 10px; font-size: 13px; }
    .k { color:#555; }
    .v { font-variant-numeric: tabular-nums; }
    .pill { display:inline-block; padding: 2px 8px; border-radius: 999px; background:#f3f4f6; font-size: 12px; }
    .err { color:#b00020; font-size: 13px; white-space: pre-wrap; margin-top: 10px; }
    .small { font-size: 12px; color:#666; margin-top: 10px; }
    @media (max-width: 760px){ .grid { grid-template-columns: 1fr; } .kv { grid-template-columns: 120px 1fr; } }
  </style>
</head>
<body>
<div class="wrap">
  <div class="hdr">
    <div>
      <div class="title">Waveland Coastal Flood Intel</div>
      <div class="sub" id="meta">Loading…</div>
    </div>
    <div class="pill" id="status">Fetching</div>
  </div>

  <div class="grid">
    <div class="card">
      <h3>“Current” (latest valid)</h3>
      <div class="kv" id="nowCard"></div>
    </div>

    <div class="card">
      <h3>~24 hours from current</h3>
      <div class="kv" id="plus24Card"></div>
    </div>
  </div>

  <div class="small" id="foot"></div>
  <div class="err" id="err"></div>
</div>

<script>
  // ==== CONFIG ====
  const GITHUB_USER = "mefferso";
  const REPO_NAME   = "PETSS";
  const BRANCH      = "main";
  const LATEST_JSON_PATH = "outputs/waveland/latest.json";

  function rawUrl(path) {
    return `https://raw.githubusercontent.com/${GITHUB_USER}/${REPO_NAME}/${BRANCH}/${path}`;
  }

  function fmtNum(x) {
    if (x == null || Number.isNaN(x)) return "—";
    return Number(x).toFixed(3);
  }

  function fmtTime(d) {
    if (!(d instanceof Date) || isNaN(d.getTime())) return "—";
    return d.toISOString().replace("T"," ").replace(":00.000Z","Z");
  }

  function parsePetssTime(s) {
    // TIME like 202602080600 (YYYYMMDDHHMM)
    const str = String(s).trim();
    if (!/^\d{12}$/.test(str)) return null;
    const Y = +str.slice(0,4);
    const M = +str.slice(4,6);
    const D = +str.slice(6,8);
    const h = +str.slice(8,10);
    const m = +str.slice(10,12);
    return new Date(Date.UTC(Y, M-1, D, h, m, 0));
  }

  function parseCsv(text) {
    const lines = text.split(/\r?\n/).filter(Boolean);
    if (lines.length < 2) return [];
    const headers = lines[0].split(",").map(h => h.trim());
    const rows = [];
    for (let i = 1; i < lines.length; i++) {
      const cols = lines[i].split(",").map(c => c.trim());
      if (cols.length !== headers.length) continue;
      const obj = {};
      for (let j = 0; j < headers.length; j++) obj[headers[j]] = cols[j];
      rows.push(obj);
    }
    return rows;
  }

  function toFloat(val) {
    const x = Number(val);
    if (!isFinite(x)) return null;
    // PETSS missing sentinel often 9999.000
    if (Math.abs(x - 9999) < 0.0005) return null;
    return x;
  }

  function rowHasValid(row) {
    const twl = toFloat(row.TWL);
    const ob  = toFloat(row.OB);
    return twl != null || ob != null;
  }

  function pickLatestValid(rows) {
    for (let i = rows.length - 1; i >= 0; i--) {
      if (rowHasValid(rows[i])) return rows[i];
    }
    return null;
  }

  function pickClosestFutureTo(rows, targetDate) {
    let best = null;
    let bestDt = Infinity;
    for (const r of rows) {
      if (!rowHasValid(r)) continue;
      const d = parsePetssTime(r.TIME);
      if (!d) continue;
      if (d.getTime() < targetDate.getTime()) continue; // future only
      const dt = d.getTime() - targetDate.getTime();
      if (dt < bestDt) { best = r; bestDt = dt; }
    }
    return best;
  }

  function renderCard(el, row) {
    if (!row) {
      el.innerHTML = `<div class="k">No valid data</div><div class="v">—</div>`;
      return;
    }
    const d = parsePetssTime(row.TIME);

    const fields = [
      ["Time (UTC)", fmtTime(d)],
      ["Tide (ft)", fmtNum(toFloat(row.TIDE))],
      ["Obs (ft)", fmtNum(toFloat(row.OB))],
      ["Surge (ft)", fmtNum(toFloat(row.SURGE))],
      ["Bias (ft)", fmtNum(toFloat(row.BIAS))],
      ["TWL (ft)", fmtNum(toFloat(row.TWL))],
      ["Surge 90p (ft)", fmtNum(toFloat(row.SURGE90p))],
      ["TWL 90p (ft)", fmtNum(toFloat(row.TWL90p))],
      ["Surge 10p (ft)", fmtNum(toFloat(row.SURGE10p))],
      ["TWL 10p (ft)", fmtNum(toFloat(row.TWL10p))],
    ];

    el.innerHTML = fields.map(([k,v]) => `<div class="k">${k}</div><div class="v">${v}</div>`).join("");
  }

  async function main() {
    const status = document.getElementById("status");
    const meta   = document.getElementById("meta");
    const foot   = document.getElementById("foot");
    const errEl  = document.getElementById("err");

    try {
      status.textContent = "Loading latest.json";
      const latest = await fetch(rawUrl(LATEST_JSON_PATH), { cache: "no-store" }).then(r => {
        if (!r.ok) throw new Error(`latest.json fetch failed: ${r.status}`);
        return r.json();
      });

      const station = latest?.station || {};
      const run = latest?.petss_latest || {};
      const generated = latest?.generated_utc || "—";

      const stationCsvPath = latest?.petss_station_csv?.path;
      const stationCsvSource = latest?.petss_station_csv?.source_file;

      if (!stationCsvPath) {
        throw new Error("latest.json missing petss_station_csv.path (Python didn't write station CSV)");
      }

      meta.textContent = `${station?.name || "Station"} • PETSS cycle t${run?.cycle || "??"}z • updated ${generated}`;
      status.textContent = "Downloading station CSV";

      const csvText = await fetch(rawUrl(stationCsvPath), { cache: "no-store" }).then(r => {
        if (!r.ok) throw new Error(`CSV fetch failed: ${r.status} for ${stationCsvPath}`);
        return r.text();
      });

      const rows = parseCsv(csvText);
      if (!rows.length) throw new Error(`Station CSV parsed zero rows: ${stationCsvPath}`);

      const current = pickLatestValid(rows);
      const currentTime = current ? parsePetssTime(current.TIME) : null;

      const plus24Target = currentTime ? new Date(currentTime.getTime() + 24*60*60*1000) : null;
      const plus24 = plus24Target ? pickClosestFutureTo(rows, plus24Target) : null;

      renderCard(document.getElementById("nowCard"), current);
      renderCard(document.getElementById("plus24Card"), plus24);

      foot.textContent = `Source: ${stationCsvPath}` +
                         (stationCsvSource ? ` (from ${stationCsvSource})` : "") +
                         ` • 9999 treated as missing`;

      status.textContent = "OK";
    } catch (e) {
      status.textContent = "ERROR";
      errEl.textContent = String(e?.stack || e);
    }
  }

  main();
</script>
</body>
</html>
